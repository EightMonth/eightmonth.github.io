<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XXL-JOB EXECUTOR 源码解析]]></title>
    <url>%2F2019%2F03%2F28%2FXXL-JOB%20EXECUTOR%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[XXL-JOB EXECUTOR 源码解析 xxl-job 是一个分布式调度框架，同时具备GLUE特性。 xxl-job 分两部分，一为执行器，二为调度器，执行器的职责是具体的作业，而调度器的职责是接收原生配置的调度策略进行任务调度执行器作业。 此文专门讲解执行器部分，全文围绕spring boot环境讲解。 xxl-job version: 2.0.2-SNAPSHOT 官方地址：http://www.xuxueli.com/xxl-job/#/ 解决了哪些问题： 统一管理分布式环境下的定时任务 界面化管理，清晰查看每一个任务的情况 监控任务执行情况及实时dashboard 集群调用、集群执行，具备HA及去除多余的分布式锁 调用顺序 加载配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * xxl-job config * * @author xuxueli 2017-04-28 */@Configuration@ComponentScan(basePackages = "com.xxl.job.executor.service.jobhandler")public class XxlJobConfig &#123; private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class); @Value("$&#123;xxl.job.admin.addresses&#125;") private String adminAddresses; @Value("$&#123;xxl.job.executor.appname&#125;") private String appName; @Value("$&#123;xxl.job.executor.ip&#125;") private String ip; @Value("$&#123;xxl.job.executor.port&#125;") private int port; @Value("$&#123;xxl.job.accessToken&#125;") private String accessToken; @Value("$&#123;xxl.job.executor.logpath&#125;") private String logPath; @Value("$&#123;xxl.job.executor.logretentiondays&#125;") private int logRetentionDays; @Bean(initMethod = "start", destroyMethod = "destroy") public XxlJobSpringExecutor xxlJobExecutor() &#123; logger.info("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init."); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppName(appName); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor; &#125;&#125; 利用spring的初始化进入到com.xxl.job.core.executor.impl.XxlJobSpringExecutor#start方法中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * xxl-job executor (for spring) * * @author xuxueli 2018-11-01 09:24:52 */public class XxlJobSpringExecutor extends XxlJobExecutor implements ApplicationContextAware &#123; @Override public void start() throws Exception &#123; // 初始化JobHandler仓库 initJobHandlerRepository(applicationContext); // 刷新Glue工厂 GlueFactory.refreshInstance(1); // 继续调用核心库提供的加载方法 super.start(); &#125; private void initJobHandlerRepository(ApplicationContext applicationContext)&#123; if (applicationContext == null) &#123; return; &#125; // 开始构建JobHandler Map&lt;String, Object&gt; serviceBeanMap = applicationContext.getBeansWithAnnotation(JobHandler.class); if (serviceBeanMap!=null &amp;&amp; serviceBeanMap.size()&gt;0) &#123; for (Object serviceBean : serviceBeanMap.values()) &#123; if (serviceBean instanceof IJobHandler)&#123; String name = serviceBean.getClass().getAnnotation(JobHandler.class).value(); IJobHandler handler = (IJobHandler) serviceBean; if (loadJobHandler(name) != null) &#123; // 名称去重 throw new RuntimeException("xxl-job jobhandler naming conflicts."); &#125; registJobHandler(name, handler); &#125; &#125; &#125; &#125; // ---------------------- applicationContext ---------------------- private static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; public static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125;&#125; 可以看到，start方法很具体的分为三步： 加载Jobhandler 根据参数刷新GLUE工厂 调用核心库加载方法 先具体看第一步： 根据spring容器提供的ApplicationContext扫描并读取所有注解了@JobHandler的Bean， 以注解@JobHandler的值作为JobHandler的名称，并且做了名称去重检查，然后再加入到由xxl-job框架维护的JobHandler仓库中，到此，JobHandler加载完毕。 由此，也可以得出扩展，只要你能办法把你的Bean并且带一个名称加入到这个由xxl-job框架维护的JobHandler仓库中，那么即使你没有经过前面的那些步骤，你这个Bean也是一个合法的JobHandler。而正好，这个JobHandler仓库提供了开放的访问方式，如下： 1234// 注入JobHandlerXxlJobExecutor.registJobHandler(String name, IJobHandler jobHandler);// 获取JobHandlerXxlJobExecutor.loadJobHandler(String name); 再来看第二步： 第二步相对来说步骤比较简单，根据参数刷新GLUE工厂，其实就是初始化一个工厂，目前只接受0和1两个参数： 0：初始化一个普通的GLUE工厂，依赖反射生成对象，同时使用GROOVY类加载器编译。 1：初始化一个Spring的GLUE工厂，依赖Spring获取对象。 最后再来看第三步： 这里开始使用前面提到的那些配置，其实前面的绝大多数配置都是有默认值可以不填的，甚至连ip、port都是可以不提供的。真正需要填的只有两个参数xxl.job.executor.appname、xxl.job.admin.addresses，然而当接入了spring-cloud-common依赖后，你这两个参数也可以不填了，这部分将在后面讲解，spring cloud环境无缝集成xxl-job。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Created by xuxueli on 2016/3/2 21:14. */public class XxlJobExecutor &#123; private static final Logger logger = LoggerFactory.getLogger(XxlJobExecutor.class); // ---------------------- param ---------------------- private String adminAddresses; private String appName; private String ip; private int port; private String accessToken; private String logPath; private int logRetentionDays; // ---------------------- start + stop ---------------------- public void start() throws Exception &#123; // 配置日志路径 XxlJobFileAppender.initLogPath(logPath); // 构建调度器客户端 initAdminBizList(adminAddresses, accessToken); // 配置日志清理线程（daemon） JobLogFileCleanThread.getInstance().start(logRetentionDays); // 构建触发回调线程 TriggerCallbackThread.getInstance().start(); // 构建执行器服务端（正式开启对外提供访问入口） port = port&gt;0?port: NetUtil.findAvailablePort(9999); ip = (ip!=null&amp;&amp;ip.trim().length()&gt;0)?ip: IpUtil.getIp(); initRpcProvider(ip, port, appName, accessToken); &#125; public void destroy()&#123; // 销毁作业仓库线程 if (jobThreadRepository.size() &gt; 0) &#123; for (Map.Entry&lt;Integer, JobThread&gt; item: jobThreadRepository.entrySet()) &#123; removeJobThread(item.getKey(), "web容器销毁然后终止作业."); &#125; jobThreadRepository.clear(); &#125; // 销毁日志清理线程 JobLogFileCleanThread.getInstance().toStop(); // 销毁触发回调线程 TriggerCallbackThread.getInstance().toStop(); // 销毁执行器服务端（正式关闭对外访问入口） stopRpcProvider(); &#125;&#125; start方法： 配置日志路径 xxl.job.executor.logpath参数定义日志路径，默认值为：/data/applogs/xxl-job/jobhandler/gluesource 构建调度器客户端 根据xxl.job.admin.addresses生成一个RPC调用对象，而最终RPC的调用对象的地址是拼接了一个/api，使用Jetty的网络包和Hessian的序列化。 配置日志清理线程 日志保留天数最少保留4天，否则永久保留。 构建触发回调线程 调度器调用执行器执行结束后，反馈结果给调度器 构建执行客户端 构建外部可以访问的web入口，向调度器注册自身，提供被调度的入口。]]></content>
      <categories>
        <category>Scheduler</category>
        <category>XXL-JOB</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 初始化及加载]]></title>
    <url>%2F2019%2F01%2F31%2FSpring%20Boot%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Spring Boot 初始化及加载1. 设置开关bannerMode (横幅模式，默认为CONSOLE) logStartupInfo (日志开关，默认为true) addCommandLineProperties (添加命令行属性开关，默认为true) headless (程序运行模式，java.jwt.headless=true) registerShutdownHook (注册销毁回调，默认为true) 2.初始化profile容器存储当前激活的profile 3.初始化3.1 推断运行环境首先判定classpath下是否包含javax.servlet.Servlet类或org.springframework.web.context.ConfigurableWebApplicationContext类，若包含二者其中一个，则推断当前程序为web程序 3.2 初始化初始工厂类加载在classpath:META-INF/spring.factories文件中属性key为org.springframework.context.ApplicationContextInitializer的值——工厂类的全限定名 3.3 初始化容器监听加载在classpath:META-INF/spring.factories文件中属性key为org.springframework.context.ApplicationListener的值——容器监听的全限定名 3.4 推断程序入口主类根据栈帧推断程序入口类 4.加载4.1 注册StopWatch并打开4.2 初始化环境配置容器4.3 初始化失败分析器4.4 响应程序运行模式（前面提到的 java.awt.headless，这里不扩展此点，自行查阅资料）4.5 加载spring boot监听加载在classpath:META-INF/spring.factories文件中属性key为org.springframework.boot.SpringApplicationRunListener的值——spring boot监听的全限定名 4.6 加载应用参数根据程序入口main（String[] args）中的参数配置对应的应用参数，等到应用参数对象。 4.7 根据应用参数及spring boot监听配置环境并提供环境配置对象获取或创建环境容器 加载配置文件并根据spring.profiles.active加载profile 加载配置文件并触发环境前监听 4.8 打印横幅4.9 创建ApplicationContext4.10 创建失败分析器加载在classpath:META-INF/spring.factories文件中属性key为org.springframework.boot.diagnostics.FailureAnalyzer的值——失败分析器的全限定名， 并且注入BeanFactory。 注意，此失败分析器与4.3提到的并不是一个失败分析器，当前创建失败分析器为配置spring.factories中的失败分析器。 4.11 前置配置ApplicationContext注入前面构建好的环境对象到ApplicationContext 根据BeanNamedGenerator和ResourceLoader后置处理ApplicationContext 应用所有初始化器 响应应用上下文前置监听 初始化日志对象 把应用参数对象加入到容器中 加载所有资源到ApplicationContext 响应应用加载时监听 4.12 刷新ApplicationContext刷新BeanFactory 自定义后置处理Bean工厂，若未继承SpringApplication并且未实现该方法，未此步骤忽略 调用Bean工厂后置处理器 注册Bean后置处理器 初始化国际化 初始化应用事件 自定义刷新，若未继承SpringApplication并且未实现该方法，未此步骤忽略 注册所有监听到容器 结束BeanFactory初始化 结束IOC容器初始化 注册销毁回调 4.13 刷新后处理回调所有Runner 4.14 响应所有上下文初始化完成时监听4.15 关闭StopWatch4.16 日志输出]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Dubbo源码架构]]></title>
    <url>%2F2018%2F12%2F22%2Fdubbo%2F</url>
    <content type="text"><![CDATA[Dubbo源码架构 个人笔记，非原创博文 最顶层概念：要么是提供方（Provider）提供服务，要么是消费方（Customer）消费服务。 源码地址：https://github.com/alibaba/dubbo 架构抽象图 架构图一说明Dubbo框架设计一共划分了10个层，而最上面的Service层是留给实际想要使用Dubbo开发分布式服务的开发者实现业务逻辑的接口层。图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口， 位于中轴线上的为双方都用到的接口。 1.业务逻辑服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。 2.RPC模块 配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类。 服务代理层（Proxy）：服务接口透明代理，生成服务的客户端访问入口和服务器端结构，以ServiceProxy为中心，扩展接口为ProxyFactory。 服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory、Registry和RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。 集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。同时这一层也是Dubbo体现服务治理的层面。 监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。 协议定义层（Protocol）：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。Protocol是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。Invoker是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。 3.远程调用协议 信息交换层（Exchange）：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer。 网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec 数据序列化层（Serialize）：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool。 额外说明从上图可以看出，Dubbo对于服务提供方和服务消费方，从框架的10层中分别提供了各自需要关心和扩展的接口，构建整个服务生态系统（服务提供方和服务消费方本身就是一个以服务为中心的）。 在RPC中，Protocol是核心层，也就是只要有Protocol + Invoker + Exporter就可以完成非透明的RPC调用，然后在Invoker的主过程上Filter拦截点。 图中的Consumer和Provider是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用Client和Server的原因是Dubbo在很多场景下都使用Provider、Consumer、Registry、Monitor划分逻辑拓普节点，保持统一概念。 Cluster是外围概念，所以Cluster的目的是将多个Invoker伪装成一个Invoker，这样其它人只要关注Protocol层Invoker即可，加上Cluster或者去掉Cluster对其它层都不会造成影响，因为只有一个提供者时，是不需要Cluster的。如果有多个提供者时，那Cluster将是Dubbo服务治理的入口，所有的服务治理都从Cluster开始并且延续到更低层的Directory、Router、LoadBalance。 Proxy层封装了所有接口的透明化代理，而在其它层都以Invoker为中心，只有到了暴露给用户使用时，才用Proxy将Invoker转成接口，或将接口实现转成Invoker，也就是去掉Proxy层RPC是可以Run的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。 Remoting实现是Dubbo协议的实现，如果你选择RMI协议，整个Remoting都不会用上，Remoting内部再划为Transport传输层和Exchange信息交换层，Transport层只负责单向消息传输，是对Mina、Netty、Grizzly的抽象，它也可以扩展UDP传输，而Exchange层是在传输层之上封装了Request-Response语义。 Registry和Monitor实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。 核心要点从上面的架构图中，我们可以了解到，Dubbo作为一个分布式服务框架，主要具有如下几个核心的要点： 1.服务定义服务是围绕服务提供方和服务消费方的，服务提供方实现服务，而服务消费方调用服务。 2.服务注册对于服务提供方，它需要发布服务，而且由于应用系统的复杂性，服务的数量、类型也不断膨胀；对于服务消费方，它最关心如何获取到它所需要的服务，而面对复杂的应用系统，需要管理大量的服务调用。而且，对于服务提供方和服务消费方来说，他们还有可能兼具这两种角色，即既需要提供服务，有需要消费服务。通过将服务统一管理起来，可以有效地优化内部应用对服务发布/使用的流程和管理。服务注册中心可以通过特定协议来完成服务对外的统一。Dubbo提供的注册中心有如下几种类型可供选择： Multicast注册中心 Zookeeper注册中心 Redis注册中心 Default注册中心 3.服务监控无论是服务提供方，还是服务消费方，他们都需要对服务调用的实际状态进行有效的监控，从而改进服务质量。 4.远程通信与信息交换远程通信需要指定通信双方所约定的协议，在保证通信双方理解协议语义的基础上，还要保证高效、稳定的消息传输。Dubbo继承了当前主流的网络通信框架，主要包括如下几个： Mina Netty Grizzly 5.服务调用 服务调用过程 上图中，蓝色的表示与业务有交互，绿色的表示只对Dubbo内部交互。上述图所描述的调用流程如下： 服务提供方发布服务到服务注册中心； 服务消费方从服务注册中心订阅服务； 服务消费方调用已经注册的可用服务。 详细如图所示： 4.服务注册与注销 5.服务订阅与取消 6.协议支持Dubbo支持自定义扩展协议，实现dubbo-rpc-api即可扩展出一种Dubbo支持的协议。Dubbo目前已实现的协议如下： Dubbo协议 Hessian协议 HTTP协议 RMI协议 WebService协议 Thrift协议 Memcached协议 Redis协议 Dubbo模块图Dubbo以包结构来组织各个模块，各个模块及其关系，如图所示： Dubbo-common 公共逻辑模块，包括Util类和通用模型。 Dubbo-remoting 远程通讯模块，相当于Dubbo协议的实现，如果RPC用RMI协议则不需要使用此包。 Dubbo-rpc 远程调用模块，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。 Dubbo-cluster 集群模块，将多个服务提供方伪装为一个提供方，包括：负载均衡、容错、路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。 Dubbo-registry 注册中心模块，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。 Dubbo-monitor 监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。 Dubbo-config 配置模块，是Dubbo对外的API，用户通过Config使用Dubbo，隐藏Dubbo所有细节。 dubbo-container 容器模块，是一个Standalone的容器，以简单的Main加载Spring启动，因为服务通常不需要Tomcat/JBoss等Web容器的特性，没必要用Web容器去加载服务。]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
  </entry>
</search>
